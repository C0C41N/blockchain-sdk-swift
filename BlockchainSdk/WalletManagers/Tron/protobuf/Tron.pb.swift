// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Tron.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Protocol_AccountType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case normal // = 0
  case assetIssue // = 1
  case contract // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .normal
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .assetIssue
    case 2: self = .contract
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .normal: return 0
    case .assetIssue: return 1
    case .contract: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Protocol_AccountType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_AccountType] = [
    .normal,
    .assetIssue,
    .contract,
  ]
}

#endif  // swift(>=4.2)

/// AccountId, (name, address) use name, (null, address) use address, (name, null) use name,
struct Protocol_AccountId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: Data = Data()

  var address: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_authority {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var account: Protocol_AccountId {
    get {return _account ?? Protocol_AccountId()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {self._account = nil}

  var permissionName: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _account: Protocol_AccountId? = nil
}

struct Protocol_MarketOrderDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var makerOrderID: Data = Data()

  var takerOrderID: Data = Data()

  var fillSellQuantity: Int64 = 0

  var fillBuyQuantity: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rawData: Protocol_Transaction.raw {
    get {return _rawData ?? Protocol_Transaction.raw()}
    set {_rawData = newValue}
  }
  /// Returns true if `rawData` has been explicitly set.
  var hasRawData: Bool {return self._rawData != nil}
  /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
  mutating func clearRawData() {self._rawData = nil}

  /// only support size = 1,  repeated list here for muti-sig extension
  var signature: [Data] = []

  var ret: [Protocol_Transaction.Result] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Contract {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Protocol_Transaction.Contract.ContractType = .accountCreateContract

    var parameter: SwiftProtobuf.Google_Protobuf_Any {
      get {return _parameter ?? SwiftProtobuf.Google_Protobuf_Any()}
      set {_parameter = newValue}
    }
    /// Returns true if `parameter` has been explicitly set.
    var hasParameter: Bool {return self._parameter != nil}
    /// Clears the value of `parameter`. Subsequent reads from it will return its default value.
    mutating func clearParameter() {self._parameter = nil}

    var provider: Data = Data()

    var contractName: Data = Data()

    var permissionID: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum ContractType: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case accountCreateContract // = 0
      case transferContract // = 1
      case transferAssetContract // = 2
      case voteAssetContract // = 3
      case voteWitnessContract // = 4
      case witnessCreateContract // = 5
      case assetIssueContract // = 6
      case witnessUpdateContract // = 8
      case participateAssetIssueContract // = 9
      case accountUpdateContract // = 10
      case freezeBalanceContract // = 11
      case unfreezeBalanceContract // = 12
      case withdrawBalanceContract // = 13
      case unfreezeAssetContract // = 14
      case updateAssetContract // = 15
      case proposalCreateContract // = 16
      case proposalApproveContract // = 17
      case proposalDeleteContract // = 18
      case setAccountIDContract // = 19
      case customContract // = 20
      case createSmartContract // = 30
      case triggerSmartContract // = 31
      case getContract // = 32
      case updateSettingContract // = 33
      case exchangeCreateContract // = 41
      case exchangeInjectContract // = 42
      case exchangeWithdrawContract // = 43
      case exchangeTransactionContract // = 44
      case updateEnergyLimitContract // = 45
      case accountPermissionUpdateContract // = 46
      case clearAbicontract // = 48
      case updateBrokerageContract // = 49
      case shieldedTransferContract // = 51
      case marketSellAssetContract // = 52
      case marketCancelOrderContract // = 53
      case UNRECOGNIZED(Int)

      init() {
        self = .accountCreateContract
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .accountCreateContract
        case 1: self = .transferContract
        case 2: self = .transferAssetContract
        case 3: self = .voteAssetContract
        case 4: self = .voteWitnessContract
        case 5: self = .witnessCreateContract
        case 6: self = .assetIssueContract
        case 8: self = .witnessUpdateContract
        case 9: self = .participateAssetIssueContract
        case 10: self = .accountUpdateContract
        case 11: self = .freezeBalanceContract
        case 12: self = .unfreezeBalanceContract
        case 13: self = .withdrawBalanceContract
        case 14: self = .unfreezeAssetContract
        case 15: self = .updateAssetContract
        case 16: self = .proposalCreateContract
        case 17: self = .proposalApproveContract
        case 18: self = .proposalDeleteContract
        case 19: self = .setAccountIDContract
        case 20: self = .customContract
        case 30: self = .createSmartContract
        case 31: self = .triggerSmartContract
        case 32: self = .getContract
        case 33: self = .updateSettingContract
        case 41: self = .exchangeCreateContract
        case 42: self = .exchangeInjectContract
        case 43: self = .exchangeWithdrawContract
        case 44: self = .exchangeTransactionContract
        case 45: self = .updateEnergyLimitContract
        case 46: self = .accountPermissionUpdateContract
        case 48: self = .clearAbicontract
        case 49: self = .updateBrokerageContract
        case 51: self = .shieldedTransferContract
        case 52: self = .marketSellAssetContract
        case 53: self = .marketCancelOrderContract
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .accountCreateContract: return 0
        case .transferContract: return 1
        case .transferAssetContract: return 2
        case .voteAssetContract: return 3
        case .voteWitnessContract: return 4
        case .witnessCreateContract: return 5
        case .assetIssueContract: return 6
        case .witnessUpdateContract: return 8
        case .participateAssetIssueContract: return 9
        case .accountUpdateContract: return 10
        case .freezeBalanceContract: return 11
        case .unfreezeBalanceContract: return 12
        case .withdrawBalanceContract: return 13
        case .unfreezeAssetContract: return 14
        case .updateAssetContract: return 15
        case .proposalCreateContract: return 16
        case .proposalApproveContract: return 17
        case .proposalDeleteContract: return 18
        case .setAccountIDContract: return 19
        case .customContract: return 20
        case .createSmartContract: return 30
        case .triggerSmartContract: return 31
        case .getContract: return 32
        case .updateSettingContract: return 33
        case .exchangeCreateContract: return 41
        case .exchangeInjectContract: return 42
        case .exchangeWithdrawContract: return 43
        case .exchangeTransactionContract: return 44
        case .updateEnergyLimitContract: return 45
        case .accountPermissionUpdateContract: return 46
        case .clearAbicontract: return 48
        case .updateBrokerageContract: return 49
        case .shieldedTransferContract: return 51
        case .marketSellAssetContract: return 52
        case .marketCancelOrderContract: return 53
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}

    fileprivate var _parameter: SwiftProtobuf.Google_Protobuf_Any? = nil
  }

  struct Result {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fee: Int64 = 0

    var ret: Protocol_Transaction.Result.code = .sucess

    var contractRet: Protocol_Transaction.Result.contractResult = .default

    var assetIssueID: String = String()

    var withdrawAmount: Int64 = 0

    var unfreezeAmount: Int64 = 0

    var exchangeReceivedAmount: Int64 = 0

    var exchangeInjectAnotherAmount: Int64 = 0

    var exchangeWithdrawAnotherAmount: Int64 = 0

    var exchangeID: Int64 = 0

    var shieldedTransactionFee: Int64 = 0

    var orderID: Data = Data()

    var orderDetails: [Protocol_MarketOrderDetail] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum code: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case sucess // = 0
      case failed // = 1
      case UNRECOGNIZED(Int)

      init() {
        self = .sucess
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .sucess
        case 1: self = .failed
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .sucess: return 0
        case .failed: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    enum contractResult: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case `default` // = 0
      case success // = 1
      case revert // = 2
      case badJumpDestination // = 3
      case outOfMemory // = 4
      case precompiledContract // = 5
      case stackTooSmall // = 6
      case stackTooLarge // = 7
      case illegalOperation // = 8
      case stackOverflow // = 9
      case outOfEnergy // = 10
      case outOfTime // = 11
      case jvmStackOverFlow // = 12
      case unknown // = 13
      case transferFailed // = 14
      case invalidCode // = 15
      case UNRECOGNIZED(Int)

      init() {
        self = .default
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .default
        case 1: self = .success
        case 2: self = .revert
        case 3: self = .badJumpDestination
        case 4: self = .outOfMemory
        case 5: self = .precompiledContract
        case 6: self = .stackTooSmall
        case 7: self = .stackTooLarge
        case 8: self = .illegalOperation
        case 9: self = .stackOverflow
        case 10: self = .outOfEnergy
        case 11: self = .outOfTime
        case 12: self = .jvmStackOverFlow
        case 13: self = .unknown
        case 14: self = .transferFailed
        case 15: self = .invalidCode
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .default: return 0
        case .success: return 1
        case .revert: return 2
        case .badJumpDestination: return 3
        case .outOfMemory: return 4
        case .precompiledContract: return 5
        case .stackTooSmall: return 6
        case .stackTooLarge: return 7
        case .illegalOperation: return 8
        case .stackOverflow: return 9
        case .outOfEnergy: return 10
        case .outOfTime: return 11
        case .jvmStackOverFlow: return 12
        case .unknown: return 13
        case .transferFailed: return 14
        case .invalidCode: return 15
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  struct raw {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var refBlockBytes: Data = Data()

    var refBlockNum: Int64 = 0

    var refBlockHash: Data = Data()

    var expiration: Int64 = 0

    var auths: [Protocol_authority] = []

    /// data not used
    var data: Data = Data()

    ///only support size = 1,  repeated list here for extension
    var contract: [Protocol_Transaction.Contract] = []

    /// scripts not used
    var scripts: Data = Data()

    var timestamp: Int64 = 0

    var feeLimit: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _rawData: Protocol_Transaction.raw? = nil
}

#if swift(>=4.2)

extension Protocol_Transaction.Contract.ContractType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_Transaction.Contract.ContractType] = [
    .accountCreateContract,
    .transferContract,
    .transferAssetContract,
    .voteAssetContract,
    .voteWitnessContract,
    .witnessCreateContract,
    .assetIssueContract,
    .witnessUpdateContract,
    .participateAssetIssueContract,
    .accountUpdateContract,
    .freezeBalanceContract,
    .unfreezeBalanceContract,
    .withdrawBalanceContract,
    .unfreezeAssetContract,
    .updateAssetContract,
    .proposalCreateContract,
    .proposalApproveContract,
    .proposalDeleteContract,
    .setAccountIDContract,
    .customContract,
    .createSmartContract,
    .triggerSmartContract,
    .getContract,
    .updateSettingContract,
    .exchangeCreateContract,
    .exchangeInjectContract,
    .exchangeWithdrawContract,
    .exchangeTransactionContract,
    .updateEnergyLimitContract,
    .accountPermissionUpdateContract,
    .clearAbicontract,
    .updateBrokerageContract,
    .shieldedTransferContract,
    .marketSellAssetContract,
    .marketCancelOrderContract,
  ]
}

extension Protocol_Transaction.Result.code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_Transaction.Result.code] = [
    .sucess,
    .failed,
  ]
}

extension Protocol_Transaction.Result.contractResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_Transaction.Result.contractResult] = [
    .default,
    .success,
    .revert,
    .badJumpDestination,
    .outOfMemory,
    .precompiledContract,
    .stackTooSmall,
    .stackTooLarge,
    .illegalOperation,
    .stackOverflow,
    .outOfEnergy,
    .outOfTime,
    .jvmStackOverFlow,
    .unknown,
    .transferFailed,
    .invalidCode,
  ]
}

#endif  // swift(>=4.2)

struct Protocol_BlockHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rawData: Protocol_BlockHeader.raw {
    get {return _rawData ?? Protocol_BlockHeader.raw()}
    set {_rawData = newValue}
  }
  /// Returns true if `rawData` has been explicitly set.
  var hasRawData: Bool {return self._rawData != nil}
  /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
  mutating func clearRawData() {self._rawData = nil}

  var witnessSignature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct raw {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timestamp: Int64 = 0

    var txTrieRoot: Data = Data()

    var parentHash: Data = Data()

    ///bytes nonce = 5;
    ///bytes difficulty = 6;
    var number: Int64 = 0

    var witnessID: Int64 = 0

    var witnessAddress: Data = Data()

    var version: Int32 = 0

    var accountStateRoot: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _rawData: Protocol_BlockHeader.raw? = nil
}

/// block
struct Protocol_Block {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactions: [Protocol_Transaction] = []

  var blockHeader: Protocol_BlockHeader {
    get {return _blockHeader ?? Protocol_BlockHeader()}
    set {_blockHeader = newValue}
  }
  /// Returns true if `blockHeader` has been explicitly set.
  var hasBlockHeader: Bool {return self._blockHeader != nil}
  /// Clears the value of `blockHeader`. Subsequent reads from it will return its default value.
  mutating func clearBlockHeader() {self._blockHeader = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _blockHeader: Protocol_BlockHeader? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Protocol_AccountType: @unchecked Sendable {}
extension Protocol_AccountId: @unchecked Sendable {}
extension Protocol_authority: @unchecked Sendable {}
extension Protocol_MarketOrderDetail: @unchecked Sendable {}
extension Protocol_Transaction: @unchecked Sendable {}
extension Protocol_Transaction.Contract: @unchecked Sendable {}
extension Protocol_Transaction.Contract.ContractType: @unchecked Sendable {}
extension Protocol_Transaction.Result: @unchecked Sendable {}
extension Protocol_Transaction.Result.code: @unchecked Sendable {}
extension Protocol_Transaction.Result.contractResult: @unchecked Sendable {}
extension Protocol_Transaction.raw: @unchecked Sendable {}
extension Protocol_BlockHeader: @unchecked Sendable {}
extension Protocol_BlockHeader.raw: @unchecked Sendable {}
extension Protocol_Block: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol"

extension Protocol_AccountType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Normal"),
    1: .same(proto: "AssetIssue"),
    2: .same(proto: "Contract"),
  ]
}

extension Protocol_AccountId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularBytesField(value: self.name, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_AccountId, rhs: Protocol_AccountId) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_authority: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".authority"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "permission_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.permissionName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.permissionName.isEmpty {
      try visitor.visitSingularBytesField(value: self.permissionName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_authority, rhs: Protocol_authority) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs.permissionName != rhs.permissionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_MarketOrderDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MarketOrderDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "makerOrderId"),
    2: .same(proto: "takerOrderId"),
    3: .same(proto: "fillSellQuantity"),
    4: .same(proto: "fillBuyQuantity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.makerOrderID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.takerOrderID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.fillSellQuantity) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.fillBuyQuantity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.makerOrderID.isEmpty {
      try visitor.visitSingularBytesField(value: self.makerOrderID, fieldNumber: 1)
    }
    if !self.takerOrderID.isEmpty {
      try visitor.visitSingularBytesField(value: self.takerOrderID, fieldNumber: 2)
    }
    if self.fillSellQuantity != 0 {
      try visitor.visitSingularInt64Field(value: self.fillSellQuantity, fieldNumber: 3)
    }
    if self.fillBuyQuantity != 0 {
      try visitor.visitSingularInt64Field(value: self.fillBuyQuantity, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_MarketOrderDetail, rhs: Protocol_MarketOrderDetail) -> Bool {
    if lhs.makerOrderID != rhs.makerOrderID {return false}
    if lhs.takerOrderID != rhs.takerOrderID {return false}
    if lhs.fillSellQuantity != rhs.fillSellQuantity {return false}
    if lhs.fillBuyQuantity != rhs.fillBuyQuantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_data"),
    2: .same(proto: "signature"),
    5: .same(proto: "ret"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rawData) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.signature) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.ret) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rawData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.signature.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.signature, fieldNumber: 2)
    }
    if !self.ret.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ret, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Transaction, rhs: Protocol_Transaction) -> Bool {
    if lhs._rawData != rhs._rawData {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.ret != rhs.ret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transaction.Contract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Transaction.protoMessageName + ".Contract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "parameter"),
    3: .same(proto: "provider"),
    4: .same(proto: "ContractName"),
    5: .standard(proto: "Permission_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._parameter) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.provider) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.contractName) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.permissionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .accountCreateContract {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._parameter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.provider.isEmpty {
      try visitor.visitSingularBytesField(value: self.provider, fieldNumber: 3)
    }
    if !self.contractName.isEmpty {
      try visitor.visitSingularBytesField(value: self.contractName, fieldNumber: 4)
    }
    if self.permissionID != 0 {
      try visitor.visitSingularInt32Field(value: self.permissionID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Transaction.Contract, rhs: Protocol_Transaction.Contract) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._parameter != rhs._parameter {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.contractName != rhs.contractName {return false}
    if lhs.permissionID != rhs.permissionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transaction.Contract.ContractType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AccountCreateContract"),
    1: .same(proto: "TransferContract"),
    2: .same(proto: "TransferAssetContract"),
    3: .same(proto: "VoteAssetContract"),
    4: .same(proto: "VoteWitnessContract"),
    5: .same(proto: "WitnessCreateContract"),
    6: .same(proto: "AssetIssueContract"),
    8: .same(proto: "WitnessUpdateContract"),
    9: .same(proto: "ParticipateAssetIssueContract"),
    10: .same(proto: "AccountUpdateContract"),
    11: .same(proto: "FreezeBalanceContract"),
    12: .same(proto: "UnfreezeBalanceContract"),
    13: .same(proto: "WithdrawBalanceContract"),
    14: .same(proto: "UnfreezeAssetContract"),
    15: .same(proto: "UpdateAssetContract"),
    16: .same(proto: "ProposalCreateContract"),
    17: .same(proto: "ProposalApproveContract"),
    18: .same(proto: "ProposalDeleteContract"),
    19: .same(proto: "SetAccountIdContract"),
    20: .same(proto: "CustomContract"),
    30: .same(proto: "CreateSmartContract"),
    31: .same(proto: "TriggerSmartContract"),
    32: .same(proto: "GetContract"),
    33: .same(proto: "UpdateSettingContract"),
    41: .same(proto: "ExchangeCreateContract"),
    42: .same(proto: "ExchangeInjectContract"),
    43: .same(proto: "ExchangeWithdrawContract"),
    44: .same(proto: "ExchangeTransactionContract"),
    45: .same(proto: "UpdateEnergyLimitContract"),
    46: .same(proto: "AccountPermissionUpdateContract"),
    48: .same(proto: "ClearABIContract"),
    49: .same(proto: "UpdateBrokerageContract"),
    51: .same(proto: "ShieldedTransferContract"),
    52: .same(proto: "MarketSellAssetContract"),
    53: .same(proto: "MarketCancelOrderContract"),
  ]
}

extension Protocol_Transaction.Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Transaction.protoMessageName + ".Result"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fee"),
    2: .same(proto: "ret"),
    3: .same(proto: "contractRet"),
    14: .same(proto: "assetIssueID"),
    15: .standard(proto: "withdraw_amount"),
    16: .standard(proto: "unfreeze_amount"),
    18: .standard(proto: "exchange_received_amount"),
    19: .standard(proto: "exchange_inject_another_amount"),
    20: .standard(proto: "exchange_withdraw_another_amount"),
    21: .standard(proto: "exchange_id"),
    22: .standard(proto: "shielded_transaction_fee"),
    25: .same(proto: "orderId"),
    26: .same(proto: "orderDetails"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.fee) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.ret) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.contractRet) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.assetIssueID) }()
      case 15: try { try decoder.decodeSingularInt64Field(value: &self.withdrawAmount) }()
      case 16: try { try decoder.decodeSingularInt64Field(value: &self.unfreezeAmount) }()
      case 18: try { try decoder.decodeSingularInt64Field(value: &self.exchangeReceivedAmount) }()
      case 19: try { try decoder.decodeSingularInt64Field(value: &self.exchangeInjectAnotherAmount) }()
      case 20: try { try decoder.decodeSingularInt64Field(value: &self.exchangeWithdrawAnotherAmount) }()
      case 21: try { try decoder.decodeSingularInt64Field(value: &self.exchangeID) }()
      case 22: try { try decoder.decodeSingularInt64Field(value: &self.shieldedTransactionFee) }()
      case 25: try { try decoder.decodeSingularBytesField(value: &self.orderID) }()
      case 26: try { try decoder.decodeRepeatedMessageField(value: &self.orderDetails) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fee != 0 {
      try visitor.visitSingularInt64Field(value: self.fee, fieldNumber: 1)
    }
    if self.ret != .sucess {
      try visitor.visitSingularEnumField(value: self.ret, fieldNumber: 2)
    }
    if self.contractRet != .default {
      try visitor.visitSingularEnumField(value: self.contractRet, fieldNumber: 3)
    }
    if !self.assetIssueID.isEmpty {
      try visitor.visitSingularStringField(value: self.assetIssueID, fieldNumber: 14)
    }
    if self.withdrawAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.withdrawAmount, fieldNumber: 15)
    }
    if self.unfreezeAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.unfreezeAmount, fieldNumber: 16)
    }
    if self.exchangeReceivedAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeReceivedAmount, fieldNumber: 18)
    }
    if self.exchangeInjectAnotherAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeInjectAnotherAmount, fieldNumber: 19)
    }
    if self.exchangeWithdrawAnotherAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeWithdrawAnotherAmount, fieldNumber: 20)
    }
    if self.exchangeID != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeID, fieldNumber: 21)
    }
    if self.shieldedTransactionFee != 0 {
      try visitor.visitSingularInt64Field(value: self.shieldedTransactionFee, fieldNumber: 22)
    }
    if !self.orderID.isEmpty {
      try visitor.visitSingularBytesField(value: self.orderID, fieldNumber: 25)
    }
    if !self.orderDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orderDetails, fieldNumber: 26)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Transaction.Result, rhs: Protocol_Transaction.Result) -> Bool {
    if lhs.fee != rhs.fee {return false}
    if lhs.ret != rhs.ret {return false}
    if lhs.contractRet != rhs.contractRet {return false}
    if lhs.assetIssueID != rhs.assetIssueID {return false}
    if lhs.withdrawAmount != rhs.withdrawAmount {return false}
    if lhs.unfreezeAmount != rhs.unfreezeAmount {return false}
    if lhs.exchangeReceivedAmount != rhs.exchangeReceivedAmount {return false}
    if lhs.exchangeInjectAnotherAmount != rhs.exchangeInjectAnotherAmount {return false}
    if lhs.exchangeWithdrawAnotherAmount != rhs.exchangeWithdrawAnotherAmount {return false}
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.shieldedTransactionFee != rhs.shieldedTransactionFee {return false}
    if lhs.orderID != rhs.orderID {return false}
    if lhs.orderDetails != rhs.orderDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transaction.Result.code: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCESS"),
    1: .same(proto: "FAILED"),
  ]
}

extension Protocol_Transaction.Result.contractResult: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "REVERT"),
    3: .same(proto: "BAD_JUMP_DESTINATION"),
    4: .same(proto: "OUT_OF_MEMORY"),
    5: .same(proto: "PRECOMPILED_CONTRACT"),
    6: .same(proto: "STACK_TOO_SMALL"),
    7: .same(proto: "STACK_TOO_LARGE"),
    8: .same(proto: "ILLEGAL_OPERATION"),
    9: .same(proto: "STACK_OVERFLOW"),
    10: .same(proto: "OUT_OF_ENERGY"),
    11: .same(proto: "OUT_OF_TIME"),
    12: .same(proto: "JVM_STACK_OVER_FLOW"),
    13: .same(proto: "UNKNOWN"),
    14: .same(proto: "TRANSFER_FAILED"),
    15: .same(proto: "INVALID_CODE"),
  ]
}

extension Protocol_Transaction.raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Transaction.protoMessageName + ".raw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ref_block_bytes"),
    3: .standard(proto: "ref_block_num"),
    4: .standard(proto: "ref_block_hash"),
    8: .same(proto: "expiration"),
    9: .same(proto: "auths"),
    10: .same(proto: "data"),
    11: .same(proto: "contract"),
    12: .same(proto: "scripts"),
    14: .same(proto: "timestamp"),
    18: .standard(proto: "fee_limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.refBlockBytes) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.refBlockNum) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.refBlockHash) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.expiration) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.auths) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.contract) }()
      case 12: try { try decoder.decodeSingularBytesField(value: &self.scripts) }()
      case 14: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 18: try { try decoder.decodeSingularInt64Field(value: &self.feeLimit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.refBlockBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.refBlockBytes, fieldNumber: 1)
    }
    if self.refBlockNum != 0 {
      try visitor.visitSingularInt64Field(value: self.refBlockNum, fieldNumber: 3)
    }
    if !self.refBlockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.refBlockHash, fieldNumber: 4)
    }
    if self.expiration != 0 {
      try visitor.visitSingularInt64Field(value: self.expiration, fieldNumber: 8)
    }
    if !self.auths.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.auths, fieldNumber: 9)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 10)
    }
    if !self.contract.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contract, fieldNumber: 11)
    }
    if !self.scripts.isEmpty {
      try visitor.visitSingularBytesField(value: self.scripts, fieldNumber: 12)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 14)
    }
    if self.feeLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.feeLimit, fieldNumber: 18)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Transaction.raw, rhs: Protocol_Transaction.raw) -> Bool {
    if lhs.refBlockBytes != rhs.refBlockBytes {return false}
    if lhs.refBlockNum != rhs.refBlockNum {return false}
    if lhs.refBlockHash != rhs.refBlockHash {return false}
    if lhs.expiration != rhs.expiration {return false}
    if lhs.auths != rhs.auths {return false}
    if lhs.data != rhs.data {return false}
    if lhs.contract != rhs.contract {return false}
    if lhs.scripts != rhs.scripts {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.feeLimit != rhs.feeLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_data"),
    2: .standard(proto: "witness_signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rawData) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.witnessSignature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rawData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.witnessSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.witnessSignature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_BlockHeader, rhs: Protocol_BlockHeader) -> Bool {
    if lhs._rawData != rhs._rawData {return false}
    if lhs.witnessSignature != rhs.witnessSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockHeader.raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_BlockHeader.protoMessageName + ".raw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "txTrieRoot"),
    3: .same(proto: "parentHash"),
    7: .same(proto: "number"),
    8: .standard(proto: "witness_id"),
    9: .standard(proto: "witness_address"),
    10: .same(proto: "version"),
    11: .same(proto: "accountStateRoot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.txTrieRoot) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.parentHash) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.number) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.witnessID) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.witnessAddress) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.accountStateRoot) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.txTrieRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.txTrieRoot, fieldNumber: 2)
    }
    if !self.parentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.parentHash, fieldNumber: 3)
    }
    if self.number != 0 {
      try visitor.visitSingularInt64Field(value: self.number, fieldNumber: 7)
    }
    if self.witnessID != 0 {
      try visitor.visitSingularInt64Field(value: self.witnessID, fieldNumber: 8)
    }
    if !self.witnessAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.witnessAddress, fieldNumber: 9)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 10)
    }
    if !self.accountStateRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.accountStateRoot, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_BlockHeader.raw, rhs: Protocol_BlockHeader.raw) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.txTrieRoot != rhs.txTrieRoot {return false}
    if lhs.parentHash != rhs.parentHash {return false}
    if lhs.number != rhs.number {return false}
    if lhs.witnessID != rhs.witnessID {return false}
    if lhs.witnessAddress != rhs.witnessAddress {return false}
    if lhs.version != rhs.version {return false}
    if lhs.accountStateRoot != rhs.accountStateRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Block"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
    2: .standard(proto: "block_header"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.transactions) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._blockHeader) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    try { if let v = self._blockHeader {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Block, rhs: Protocol_Block) -> Bool {
    if lhs.transactions != rhs.transactions {return false}
    if lhs._blockHeader != rhs._blockHeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
